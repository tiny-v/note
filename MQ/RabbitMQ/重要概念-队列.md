## 重要概念 

### 队列(Queue)
> 参考内容： https://www.cnblogs.com/refuge/p/10354579.html

> 1. 队列一旦声明,参数将无法更改,添加,删除; 只能删除重建

#### 1.声明队列的参数
```
1. queue  //队列名称. [String]

2. durable // 队列是否持久化. [Boolean] 
           // false:队列在内存中,服务器挂掉后,队列就没了;
           // true:服务器重启后,队列将会重新生成.注意:只是队列持久化,不代表队列中的消息持久化!!!!
          
2. exclusive // 队列是否专属. [Boolean]
             // 专属的范围针对的是连接,也就是说,一个连接下面的多个信道是可见的.对于其他连接是不可见的.
             // 连接断开后,该队列会被删除.注意,不是信道断开,是连接断开.并且,就算设置成了持久化,也会删除.
             
4. autoDelete // 如果所有消费者都断开连接了,是否自动删除. [Boolean] 
              // 如果还没有消费者从该队列获取过消息或者监听该队列,那么该队列不会删除.只有在有消费者从该队列获取过消息后,该队列才有可能自动删除(当所有消费者都断开连接,不管消息是否获取完)

5. arguments // 队列的配置 Map<String, Object>
```

#### 2. 上面第5条队列的配置参数
```
x-message-ttl : 队列中的消息超时时间； 单位：mills

x-expires : 队列多久没被访问后，会自动删除; 单位：mills; 问题： 如果一个队列被声明为持久化了，也会被删除么？

x-max-length : 队列可以容纳的消息的最大条数, 超过这个size后， 默认队列头部的消息将会被丢弃；

x-max-length-bytes : 队列可以容纳的消息的最大字节数，超过这个字节数, 默认队列头部的消息将会被丢弃.

x-overflow : 队列中的消息溢出后如何处理； 有两种可选策略( 拒绝策略[reject-publish]  && 丢弃头部策略[drop-head] )

x-dead-letter-exchange : 溢出的消息需要发送到绑定该死信交换机的队列

x-dead-letter-routing-key : 溢出的消息需要发送到绑定该死信交换机,并且路由键匹配的队列

x-single-active-consumer：true/false 表示是否最多只允许一个消费者消费，如果有多个消费者同时绑定，则只会激活第一个，
                                     除非第一个消费者被取消或者死亡，才会自动转到下一个消费者

x-max-priority : 消息的最大优先级；发布消息的时候,可以指定消息的优先级,优先级高的先被消费.
                 如果没有设置该参数,那么该队列不支持消息优先级功能.也就是说,就算发布消息的时候传入了优先级的值,也不会起什么作用.
                 如果消息的优先级超过这个值，那这些消息将按顺序被处理

x-queue-mode : 懒人模式，值为(lazy). 
               设置队列为懒人模式.该模式下的队列会先将交换机推送过来的消息(尽可能多的)保存在磁盘上,以减少内存的占用.
               当消费者开始消费的时候才加载到内存中; 如果没有设置懒人模式,队列则会直接利用内存缓存,以最快的速度传递消息

x-queue-master-locator :  集群相关，，暂时不知道。
```