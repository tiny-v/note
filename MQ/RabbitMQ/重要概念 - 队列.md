
## 队列(Queue)

### 参考内容
> 1. https://www.cnblogs.com/refuge/p/10354579.html

```
Tips: 通常队列一旦声明,参数将无法更改,添加,删除, 只能删除重建; 
```
### 一.声明队列的参数

<b>1. queue</b>
>队列名称. [String]

<b>2. durable</b>
> 队列是否持久化. [Boolean]
> 
> false: 队列在内存中,服务器挂掉后,队列就没了;
> 
> true: 服务器重启后,队列将会重新生成.注意:只是队列持久化,不代表队列中的消息持久化!!!!
          
<b>3. exclusive</b> 
> 队列是否专属. [Boolean]
> 
> 专属的范围针对的是连接,也就是说,一个连接下面的多个信道是可见的.对于其他连接是不可见的.
> 
> 连接断开后,该队列会被删除.注意,不是信道断开,是连接断开.并且,就算设置成了持久化,也会删除.
             
<b>4. autoDelete</b> 
> 如果所有消费者都断开连接了,是否自动删除. [Boolean] 
> 
> 如果还没有消费者从该队列获取过消息或者监听该队列,那么该队列不会删除.只有在有消费者从该队列获取过消息后,该队列才有可能自动删除(当所有消费者都断开连接,不管消息是否获取完)

<b>5. arguments</b> 
> 队列的配置 Map<String, Object>


### 二. 上面第5条队列的配置参数

<b>1. x-message-ttl</b>: 
> 队列中的消息超时时间； 单位：mills

<b>2. x-expires</b>: 
> 队列多久没被访问后，会自动删除; 单位：mills; 问题： 如果一个队列被声明为持久化了，也会被删除么？

<b>3. x-max-length</b>: 
> 队列可以容纳的消息的最大条数, 超过这个size后， 默认队列头部的消息将会被丢弃；

<b>4. x-max-length-bytes</b>: 
> 队列可以容纳的消息的最大字节数，超过这个字节数, 默认队列头部的消息将会被丢弃.

<b>5. x-overflow</b> : 
> 队列中的消息溢出后如何处理； 有两种可选策略( 拒绝策略[reject-publish]  && 丢弃头部策略[drop-head] )

<b>6. x-dead-letter-exchange</b>: 
> 溢出的消息需要发送到绑定该死信交换机的队列

<b>7. x-dead-letter-routing-key</b>: 
> 溢出的消息需要发送到绑定该死信交换机,并且路由键匹配的队列

<b>8. x-single-active-consumer</b>：
>true/false 表示是否最多只允许一个消费者消费，如果有多个消费者同时绑定，则只会激活第一个，除非第一个消费者被取消或者死亡，才会自动转到下一个消费者

<b>9. x-max-priority</b>: 
>消息的最大优先级；发布消息的时候,可以指定消息的优先级,优先级高的先被消费.
> 
> 如果没有设置该参数,那么该队列不支持消息优先级功能.也就是说,就算发布消息的时候传入了优先级的值,也不会起什么作用. 
>
> 如果消息的优先级超过这个值，那这些消息将按顺序被处理

<b>10. x-queue-mode</b> :
> 懒人模式，值为(lazy).
> 
> 设置队列为懒人模式.该模式下的队列会先将交换机推送过来的消息(尽可能多的)保存在磁盘上,以减少内存的占用.
>
> 当消费者开始消费的时候才加载到内存中; 如果没有设置懒人模式,队列则会直接利用内存缓存,以最快的速度传递消息

<b>11. x-queue-master-locator</b> :
> 集群相关，，暂时不知道。
