
## MQ & RabbitMQ


### 一、MQ

#### 1.1 简介

> MQ（Message Queue）消息队列，是基础数据结构中“先进先出”的一种数据结构。指把要传输的数据（消息）放在队列中，用队列机制来实现消息传递——生产者产生消息并把消息放入队列，然后由消费者去处理。消费者可以到指定队列拉取消息，或者订阅相应的队列，由MQ服务端给其推送消息。

#### 1.2 特点

<b>1.2.1 先进先出</b>
> 不能先进先出，都不能说是队列了。消息队列的顺序在入队的时候就基本已经确定了，一般是不需人工干预的。而且，最重要的是，数据是只有一条数据在使用中。 这也是MQ在诸多场景被使用的原因。

<b>1.2.2 发布订阅</b>
> 发布订阅是一种很高效的处理方式，如果不发生阻塞，基本可以当做是同步操作。这种处理方式能非常有效的提升服务器利用率，这样的应用场景非常广泛。

<b>1.2.3 持久化</b>
> 持久化确保MQ的使用不只是一个部分场景的辅助工具，而是让MQ能像数据库一样存储核心的数据。

<b>1.2.4 分布式</b>
> 在现在大流量、大数据的使用场景下，只支持单体应用的服务器软件基本是无法使用的，支持分布式的部署，才能被广泛使用。而且，MQ的定位就是一个高性能的中间件

### 二、MQ 应用场景

#### 2.1 异步处理

#### 2.2 应用解耦

#### 2.3 流量削峰

#### 2.4 广播

#### 2.5 .... 其它

#### 

### 三、 AMQP (Advanced Message Queue Protocol) 高级消息队列协议 

![img.png](img/amqp.png)

<b> Broker/Server(消息代理服务器):</b> 

<b> vhost(虚拟主机):</b>

> 本质上就是一个mini版的代理服务器（拥有自己的队列、交换器和绑定，用于进行逻辑隔离，是最上层的消息路由。
>
> 拥有自己的权限机制，RabbitMQ默认的vhost：“/”, 每个用户只能访问自己的vhost（通常会被指派至少一个vhost），进而用户只能访问自己的队列、交换器和绑定。
>
> 一个vhost里面可以有若干个Exchange和Queue，但不能存在相同名称的Exchange或相同名称的Queue.

<b> Exchange(交换器):</b>

> 接收消息，再根据匹配规则，分发消息到队列（queue）中去。

<b> Queue(消息队列):</b> 

> 保存消息并将他们转发给消费者

<b> Binding Key(绑定规则):</b>

> Exchange 和 Queue 之间的绑定规则

<b> Message(消息):</b>

> 由 Properties 和 Body 组成， Properties可对消息进行修饰，比如消息的优先级，延迟等高级特性； Body就是消息体中的内容；

<b> Routing key(路由规则):</b>

> 路由规则， 交换器可以用它来确定如何路由一个特定的消息

<b> Producer(生产者):</b>

> 消息来源

<b> Consumer(消费者):</b>

> 消费消息

<b> Connection(连接):</b>

> 客户端与代理服务器建立的TCP连接

<b> Channel(信道):</b>

> 客户端和代理服务器之间TCP连接内的虚拟连接，解决TCP连接数量限制及降低TCP连接代价。每个信道有一个ID，其概念与“多路复用”类似。

 



